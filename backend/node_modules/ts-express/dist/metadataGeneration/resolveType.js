"use strict";
const ts = require("typescript");
const metadataGenerator_1 = require("./metadataGenerator");
const syntaxKindMap = {};
syntaxKindMap[ts.SyntaxKind.NumberKeyword] = 'number';
syntaxKindMap[ts.SyntaxKind.StringKeyword] = 'string';
syntaxKindMap[ts.SyntaxKind.BooleanKeyword] = 'boolean';
syntaxKindMap[ts.SyntaxKind.VoidKeyword] = 'void';
const localReferenceTypeCache = {};
const inProgressTypes = {};
function ResolveType(typeNode) {
    const primitiveType = syntaxKindMap[typeNode.kind];
    if (primitiveType) {
        return primitiveType;
    }
    if (typeNode.kind === ts.SyntaxKind.ArrayType) {
        const arrayType = typeNode;
        return {
            elementType: ResolveType(arrayType.elementType)
        };
    }
    if (typeNode.kind === ts.SyntaxKind.UnionType) {
        return 'object';
    }
    if (typeNode.kind !== ts.SyntaxKind.TypeReference) {
        throw new Error(`Unknown type: ${ts.SyntaxKind[typeNode.kind]}`);
    }
    let typeReference = typeNode;
    if (typeReference.typeName.text === 'Date') {
        return 'datetime';
    }
    if (typeReference.typeName.text === 'Buffer') {
        return 'buffer';
    }
    if (typeReference.typeName.text === 'Promise') {
        typeReference = typeReference.typeArguments[0];
        return ResolveType(typeReference);
    }
    return generateReferenceType(typeReference.typeName.text);
}
exports.ResolveType = ResolveType;
function generateReferenceType(typeName, cacheReferenceType = true) {
    try {
        const existingType = localReferenceTypeCache[typeName];
        if (existingType) {
            return existingType;
        }
        if (inProgressTypes[typeName]) {
            return createCircularDependencyResolver(typeName);
        }
        inProgressTypes[typeName] = true;
        const modelTypeDeclaration = getModelTypeDeclaration(typeName);
        const properties = getModelTypeProperties(modelTypeDeclaration);
        const referenceType = {
            description: getModelDescription(modelTypeDeclaration),
            name: typeName,
            properties: properties
        };
        if (modelTypeDeclaration.kind === ts.SyntaxKind.TypeAliasDeclaration) {
            const innerType = modelTypeDeclaration.type;
            if (innerType.kind === ts.SyntaxKind.UnionType && innerType.types) {
                const unionTypes = innerType.types;
                referenceType.enum = unionTypes.map((unionNode) => unionNode.literal.text);
            }
        }
        const extendedProperties = getInheritedProperties(modelTypeDeclaration);
        referenceType.properties = referenceType.properties.concat(extendedProperties);
        if (cacheReferenceType) {
            metadataGenerator_1.MetadataGenerator.current.AddReferenceType(referenceType);
        }
        localReferenceTypeCache[typeName] = referenceType;
        return referenceType;
    }
    catch (err) {
        console.error(`There was a problem resolving type of '${typeName}'.`);
        throw err;
    }
}
function createCircularDependencyResolver(typeName) {
    const referenceType = {
        description: '',
        name: typeName,
        properties: new Array()
    };
    metadataGenerator_1.MetadataGenerator.current.OnFinish(referenceTypes => {
        const realReferenceType = referenceTypes[typeName];
        if (!realReferenceType) {
            return;
        }
        referenceType.description = realReferenceType.description;
        referenceType.name = realReferenceType.name;
        referenceType.properties = realReferenceType.properties;
    });
    return referenceType;
}
function getModelTypeDeclaration(typeName) {
    const nodeIsNotUsable = (node) => {
        switch (node.kind) {
            case ts.SyntaxKind.InterfaceDeclaration:
            case ts.SyntaxKind.ClassDeclaration:
            case ts.SyntaxKind.TypeAliasDeclaration:
                return false;
            default: return true;
        }
    };
    const modelTypes = metadataGenerator_1.MetadataGenerator.current.nodes
        .filter(node => {
        if (nodeIsNotUsable(node) || !metadataGenerator_1.MetadataGenerator.current.IsExportedNode(node)) {
            return false;
        }
        const modelTypeDeclaration = node;
        return modelTypeDeclaration.name.text.toLowerCase() === typeName.toLowerCase();
    });
    if (!modelTypes.length) {
        throw new Error(`No matching model found for referenced type ${typeName}`);
    }
    if (modelTypes.length > 1) {
        throw new Error(`Multiple matching models found for referenced type ${typeName}; please make model names unique.`);
    }
    return modelTypes[0];
}
function getModelTypeProperties(node) {
    if (node.kind === ts.SyntaxKind.InterfaceDeclaration) {
        const interfaceDeclaration = node;
        return interfaceDeclaration.members
            .filter(member => member.kind === ts.SyntaxKind.PropertySignature)
            .map((property) => {
            const propertyDeclaration = property;
            const identifier = propertyDeclaration.name;
            if (!propertyDeclaration.type) {
                throw new Error('No valid type found for property declaration.');
            }
            return {
                description: getNodeDescription(propertyDeclaration),
                name: identifier.text,
                required: !property.questionToken,
                type: ResolveType(propertyDeclaration.type)
            };
        });
    }
    if (node.kind === ts.SyntaxKind.TypeAliasDeclaration) {
        /**
         * TOOD
         *
         * Flesh this out so that we can properly support Type Alii instead of just assuming
         * string literal enums
        */
        return [];
    }
    const classDeclaration = node;
    let properties = classDeclaration.members.filter((member) => {
        if (member.kind !== ts.SyntaxKind.PropertyDeclaration) {
            return false;
        }
        const propertySignature = member;
        return propertySignature && hasPublicModifier(propertySignature);
    });
    const classConstructor = classDeclaration.members.find((member) => member.kind === ts.SyntaxKind.Constructor);
    if (classConstructor && classConstructor.parameters) {
        properties = properties.concat(classConstructor.parameters.filter(parameter => hasPublicModifier(parameter)));
    }
    return properties
        .map(declaration => {
        const identifier = declaration.name;
        if (!declaration.type) {
            throw new Error('No valid type found for property declaration.');
        }
        return {
            description: getNodeDescription(declaration),
            name: identifier.text,
            required: !declaration.questionToken,
            type: ResolveType(declaration.type)
        };
    });
}
function hasPublicModifier(node) {
    return !node.modifiers || node.modifiers.every(modifier => {
        return modifier.kind !== ts.SyntaxKind.ProtectedKeyword && modifier.kind !== ts.SyntaxKind.PrivateKeyword;
    });
}
function getInheritedProperties(modelTypeDeclaration) {
    const properties = new Array();
    if (modelTypeDeclaration.kind === ts.SyntaxKind.TypeAliasDeclaration) {
        return [];
    }
    const heritageClauses = modelTypeDeclaration.heritageClauses;
    if (!heritageClauses) {
        return properties;
    }
    heritageClauses.forEach(clause => {
        if (!clause.types) {
            return;
        }
        clause.types.forEach(t => {
            const baseIdentifier = t.expression;
            generateReferenceType(baseIdentifier.text, false).properties
                .forEach(property => properties.push(property));
        });
    });
    return properties;
}
function getModelDescription(modelTypeDeclaration) {
    return getNodeDescription(modelTypeDeclaration);
}
function getNodeDescription(node) {
    let symbol = metadataGenerator_1.MetadataGenerator.current.typeChecker.getSymbolAtLocation(node.name);
    /**
    * TODO: Workaround for what seems like a bug in the compiler
    * Warrants more investigation and possibly a PR against typescript
    */
    //
    if (node.kind === ts.SyntaxKind.Parameter) {
        // TypeScript won't parse jsdoc if the flag is 4, i.e. 'Property'
        symbol.flags = 0;
    }
    let comments = symbol.getDocumentationComment();
    if (comments.length) {
        return ts.displayPartsToString(comments);
    }
    return '';
}
//# sourceMappingURL=resolveType.js.map