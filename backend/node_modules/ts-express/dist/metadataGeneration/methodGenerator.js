"use strict";
const ts = require("typescript");
const metadataGenerator_1 = require("./metadataGenerator");
const resolveType_1 = require("./resolveType");
const parameterGenerator_1 = require("./parameterGenerator");
class MethodGenerator {
    constructor(node) {
        this.node = node;
        this.processMethodDecorators();
    }
    IsValid() {
        return !!this.method;
    }
    Generate() {
        if (!this.IsValid()) {
            throw new Error('This isn\'t a valid a controller method.');
        }
        if (!this.node.type) {
            throw new Error('Controller methods must have a return type.');
        }
        const identifier = this.node.name;
        return {
            description: this.getMethodDescription(),
            example: this.getMethodExample(),
            method: this.method,
            name: identifier.text,
            parameters: this.getParameters(),
            path: this.path,
            responses: this.getResponses(),
            security: this.getMethodSecurity(),
            tags: this.getMethodTags(),
            type: resolveType_1.ResolveType(this.node.type),
        };
    }
    getParameters() {
        return this.node.parameters.map(p => {
            return new parameterGenerator_1.ParameterGenerator(p).Generate();
        });
    }
    processMethodDecorators() {
        const pathDecorators = this.getDecorators(identifier => {
            return this.getValidMethods().some(m => m.toLowerCase() === identifier.text.toLowerCase());
        });
        if (!pathDecorators || !pathDecorators.length) {
            return;
        }
        if (pathDecorators.length > 1) {
            throw new Error(`Only one path decorator allowed per method. Found: ${pathDecorators.map(d => d.text).join(', ')}`);
        }
        const decorator = pathDecorators[0];
        const expression = decorator.parent;
        const decoratorArgument = expression.arguments[0];
        this.method = this.convertMethodDecoratorNameToMethod(decorator.text.toLowerCase());
        // if you don't pass in a path to the method decorator, we'll just use the base route
        // todo: what if someone has multiple no argument methods of the same type in a single controller?
        // we need to throw an error there
        this.path = decoratorArgument ? `${decoratorArgument.text}` : '';
    }
    convertMethodDecoratorNameToMethod(decoratorName) {
        if (decoratorName === 'del') {
            return 'delete';
        }
        return decoratorName;
    }
    getDecorators(isMatching) {
        const decorators = this.node.decorators;
        if (!decorators || !decorators.length) {
            return undefined;
        }
        return decorators
            .map(d => d.expression)
            .map(e => e.expression)
            .filter(isMatching);
    }
    getResponses() {
        const responses = new Array();
        const defaultResponse = this.getDefaultResponse();
        if (defaultResponse) {
            responses.push(defaultResponse);
        }
        const decorators = this.getDecorators(identifier => identifier.text === 'Response');
        if (!decorators || !decorators.length) {
            return responses;
        }
        responses.concat(decorators.map(decorator => {
            const expression = decorator.parent;
            return {
                description: expression.arguments[1].text,
                name: expression.arguments[0].text,
                schema: (expression.typeArguments && expression.typeArguments.length > 0) ? resolveType_1.ResolveType(expression.typeArguments[0]) : undefined
            };
        }));
        return responses;
    }
    getDefaultResponse() {
        const decorators = this.getDecorators(identifier => identifier.text === 'DefaultResponse');
        if (!decorators || !decorators.length) {
            return undefined;
        }
        if (decorators.length > 1) {
            throw new Error('Only one DefaultResponse decorator allowed per controller method.');
        }
        const decorator = decorators[0];
        const expression = decorator.parent;
        let description = '';
        if (expression.arguments.length > 0 &&
            expression.arguments[0] &&
            expression.arguments[0].text) {
            description = expression.arguments[0].text;
        }
        return {
            description,
            name: 'default',
            schema: (expression.typeArguments && expression.typeArguments.length > 0) ? resolveType_1.ResolveType(expression.typeArguments[0]) : undefined
        };
    }
    getValidMethods() {
        return ['get', 'post', 'del', 'put'];
    }
    getMethodDescription() {
        let symbol = metadataGenerator_1.MetadataGenerator.current.typeChecker.getSymbolAtLocation(this.node.name);
        let comments = symbol.getDocumentationComment();
        if (comments.length) {
            return ts.displayPartsToString(comments);
        }
        return '';
    }
    getMethodExample() {
        const exampleDecorators = this.getDecorators(identifier => identifier.text === 'Example');
        if (!exampleDecorators || !exampleDecorators.length) {
            return undefined;
        }
        if (exampleDecorators.length > 1) {
            throw new Error('Only one Example decorator allowed per controller method.');
        }
        const example = {};
        const decorator = exampleDecorators[0];
        const expression = decorator.parent;
        const argument = expression.arguments[0];
        argument.properties.forEach((p) => {
            example[p.name.text] = this.getInitializerValue(p.initializer);
        });
        return example;
    }
    getMethodTags() {
        const tagsDecorators = this.getDecorators(identifier => identifier.text === 'Tags');
        if (!tagsDecorators || !tagsDecorators.length) {
            return [];
        }
        if (tagsDecorators.length > 1) {
            throw new Error('Only one Tags decorator allowed per controller method.');
        }
        const decorator = tagsDecorators[0];
        const expression = decorator.parent;
        return expression.arguments.map((a) => a.text);
    }
    getMethodSecurity() {
        const securityDecorators = this.getDecorators(identifier => identifier.text === 'Security');
        if (!securityDecorators || !securityDecorators.length) {
            return undefined;
        }
        if (securityDecorators.length > 1) {
            throw new Error('Only one Security decorator allowed per controller method.');
        }
        const decorator = securityDecorators[0];
        const expression = decorator.parent;
        return {
            name: expression.arguments[0].text,
            scopes: expression.arguments[1] ? expression.arguments[1].elements.map((e) => e.text) : undefined
        };
    }
    getInitializerValue(initializer) {
        switch (initializer.kind) {
            case ts.SyntaxKind.ArrayLiteralExpression:
                return initializer.elements.map((e) => this.getInitializerValue(e));
            case ts.SyntaxKind.StringLiteral:
                return initializer.text;
            case ts.SyntaxKind.TrueKeyword:
                return true;
            case ts.SyntaxKind.FalseKeyword:
                return false;
            case ts.SyntaxKind.NumberKeyword:
            case ts.SyntaxKind.FirstLiteralToken:
                return parseInt(initializer.text, 10);
            case ts.SyntaxKind.ObjectLiteralExpression:
                const nestedObject = {};
                initializer.properties.forEach((p) => {
                    nestedObject[p.name.text] = this.getInitializerValue(p.initializer);
                });
                return nestedObject;
            default:
                return undefined;
        }
    }
}
exports.MethodGenerator = MethodGenerator;
//# sourceMappingURL=methodGenerator.js.map