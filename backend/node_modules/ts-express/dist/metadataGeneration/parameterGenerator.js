"use strict";
const metadataGenerator_1 = require("./metadataGenerator");
const resolveType_1 = require("./resolveType");
const ts = require("typescript");
class ParameterGenerator {
    constructor(parameter) {
        this.parameter = parameter;
    }
    Generate() {
        const parameterIdentifier = this.parameter.name;
        const decorators = this.getDecorators(identifier => {
            return this.getValidInjectors().some(m => m === identifier.text);
        });
        if (!decorators || decorators.length === 0) {
            throw new Error("each parameter must have decorator");
        }
        if (decorators.length > 1) {
            throw new Error(`each parameter must have only one decorator . Found: ${decorators.map(d => d.text).join(', ')}`);
        }
        let decorator = decorators[0];
        switch (decorator.text) {
            case 'fBody':
                return this.getBodyParameter(this.parameter);
            case 'fQuery':
                return this.getQueryParameter(this.parameter);
            case 'fUrl':
                return this.getPathParameter(this.parameter);
            default:
                return {
                    description: this.getParameterDescription(this.parameter),
                    in: 'inject',
                    injected: true,
                    name: parameterIdentifier.text,
                    required: !this.parameter.questionToken,
                    type: 'object'
                };
        }
        // if (injectDecorators && injectDecorators.length === 1) {
        //   return {
        //     description: this.getParameterDescription(this.parameter),
        //     in: 'inject',
        //     injected: <InjectType>injectDecorators[0].text.toLowerCase(),
        //     name: parameterIdentifier.text,
        //     required: !this.parameter.questionToken,
        //     type: 'object'
        //   };
        // }
        // if (this.path.includes(`${parameterIdentifier.text}`)) {
        //   return this.getPathParameter(this.parameter);
        // }
        // if (this.supportsBodyParameters(this.method)) {
        //   try {
        //     return this.getQueryParameter(this.parameter);
        //   } catch (err) {
        //     if (err instanceof InvalidParameterException) {
        //       return this.getBodyParameter(this.parameter);
        //     }
        //     throw err;
        //   }
        // }
        // return this.getQueryParameter(this.parameter);
    }
    getBodyParameter(parameter) {
        const type = this.getValidatedType(parameter);
        const identifier = parameter.name;
        return {
            description: this.getParameterDescription(parameter),
            in: 'body',
            name: identifier.text,
            required: !parameter.questionToken,
            type: type
        };
    }
    getQueryParameter(parameter) {
        const type = this.getValidatedType(parameter);
        const identifier = parameter.name;
        if (!this.isPathableType(type)) {
            throw new InvalidParameterException(`Parameter '${identifier.text}' can't be passed as a query parameter.`);
        }
        return {
            description: this.getParameterDescription(parameter),
            in: 'query',
            name: identifier.text,
            required: !parameter.questionToken,
            type: type
        };
    }
    getPathParameter(parameter) {
        const type = this.getValidatedType(parameter);
        const identifier = parameter.name;
        if (!this.isPathableType(type)) {
            throw new InvalidParameterException(`Parameter '${identifier.text}' can't be passed as a path parameter.`);
        }
        return {
            description: this.getParameterDescription(parameter),
            in: 'path',
            name: identifier.text,
            // TODISCUSS: Path parameters should always be required...right?
            // Apparently express doesn't think so, but I think being able to
            // have combinations of required and optional path params makes behavior
            // pretty confusing to clients
            required: true,
            type: type
        };
    }
    getParameterDescription(node) {
        const symbol = metadataGenerator_1.MetadataGenerator.current.typeChecker.getSymbolAtLocation(node.name);
        const comments = symbol.getDocumentationComment();
        if (comments.length) {
            return ts.displayPartsToString(comments);
        }
        return '';
    }
    // private supportsBodyParameters(method: string) {
    //   return ['post', 'put', 'patch'].some(m => m === method.toLowerCase());
    // }
    isPathableType(parameterType) {
        if (!(typeof parameterType === 'string' || parameterType instanceof String)) {
            return false;
        }
        const type = parameterType;
        return !!['string', 'boolean', 'number', 'datetime', 'buffer'].find(t => t === type);
    }
    getValidatedType(parameter) {
        if (!parameter.type) {
            throw new Error(`Parameter ${parameter.name} doesn't have a valid type assigned.`);
        }
        return resolveType_1.ResolveType(parameter.type);
    }
    getDecorators(isMatching) {
        const decorators = this.parameter.decorators;
        if (!decorators || !decorators.length) {
            return undefined;
        }
        return decorators
            .map(d => d.expression)
            .map(e => e.expression)
            .filter(isMatching);
    }
    getValidInjectors() {
        return ['fUrl', 'fBody', 'fQuery', 'request', 'response', 'fInject'];
    }
}
exports.ParameterGenerator = ParameterGenerator;
class InvalidParameterException extends Error {
}
//# sourceMappingURL=parameterGenerator.js.map